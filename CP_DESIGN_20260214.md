# Checkpoints:
- CP_DESIGN_20260214.md — Initial design phase complete

## Current Status

Design phase complete for the gbe-transport distributed event backbone. All architecture docs written and decisions recorded. Project renamed from `gbe-notify` to `gbe-transport`. Ready to begin Rust project setup.

## Todo List State

### Completed
- Message broker/event bus research and comparison (Kafka rejected, NATS evaluated, Redis Streams chosen)
- Subject/topic hierarchy design (`gbe.{domain}.{entity}.{qualifier}`)
- Transport abstraction layer design (interface, envelope, Redis/NATS mapping)
- KV state store abstraction design (field-level ops, CAS, sweeper queries)
- Sweeper & archiver design (retention enforcement, S3 archival, lag protection)
- Domain schema template (minimal onboarding pattern for new domains)
- Resolved all 4 open questions (customer partitioning, retention, schemas, task stream granularity)
- Reviewed ~/projects/gbe/ for overlap — confirmed separate concerns, no conflict
- Renamed project from gbe-notify to gbe-transport
- Moved NTFY API schema to `docs/domains/notify/api-compatibility.md`

### In Progress
- None (clean stopping point)

### Pending
- Rust workspace setup (crates: transport, transport-redis, state-store, state-store-redis, sweeper)
- Implement transport trait + envelope
- Implement Redis Streams transport backend
- Implement KV state store trait
- Implement Redis KV state store backend
- Implement sweeper process
- Implement archiver process
- Domain schemas (deferred — each consuming project brings its own)
- Bridge adapter between gbe (local tool composition) and gbe-transport (distributed)

## Recent Progress

Full design doc suite created in `docs/research/`:

| File | Purpose |
|---|---|
| `message-broker-notes.md` | Hub doc — all decisions, links to everything |
| `subject-hierarchy.md` | Topic naming, stream layout, resolved Q1-Q4 |
| `transport-abstraction.md` | Core interface, envelope, Redis/NATS impl notes |
| `kv-state-store.md` | State store trait, CAS, field-level ops, scan |
| `sweeper-archiver.md` | Retention, S3 archival, lag-aware trimming |
| `domain-schema-template.md` | Onboarding template for new domains |

Also: `docs/domains/notify/api-compatibility.md` (ntfy Android app API schema)

## Current Context

### Key Architecture Decisions
- **Transport**: Redis Streams on AWS MemoryDB (already in infra). NATS JetStream as future swap — abstraction boundary enables this.
- **Envelope**: Minimal — `message_id`, `subject`, `timestamp`, `trace_id`, `payload` (opaque bytes). Fields like `schema_ver`, `content_type`, `domain` were deliberately removed — they belong in the payload, not the envelope. Transport is a dumb pipe.
- **3 Domains**: notify (internal devops ntfy), events (observability), tasks (orchestration). Each domain owns its own payload schema.
- **Task Streams**: 3 per task type — `queue` (workers), `progress` (orchestrator), `terminal` (monitors). Driven by consumer role, not lifecycle state. ~50 task types expected, peak 10k msgs/min on hot types.
- **Claim Check Pattern**: Producer stores large data in S3, publishes reference. Transport enforces `max_payload_size` (1MB) as safety rail.
- **Retention**: Per-domain TTLs (72h–7d live). Audit drains to S3 via archiver before sweeper trims.
- **Schemas**: Shared type definitions in Rust/Go/Python. No registry service. Required payload fields: `v` (schema version), `ts` (event time), `id` (dedup key).
- **No JavaScript** in the stack.

### Relationship to ~/projects/gbe/
- GBE = local tool composition substrate (Unix sockets, binary frames, adapters, router)
- gbe-transport = distributed event backbone (Redis Streams, envelopes, consumer groups)
- Different layers, no code overlap. Bridge via a thin GBE adapter that subscribes to transport streams.

### Design Philosophy
- Avoid fancy for fancy sake — direct, boring, correct
- Don't over-normalize past the point where implementation feedback is needed
- Transport is a dumb pipe; domains own their schemas
- Config-driven onboarding for new task types and domains

## Next Steps

1. Set up Rust workspace at `~/projects/gbe-transport/`
   - Root `Cargo.toml` with workspace members
   - `crates/transport/` — core trait + envelope
   - `crates/transport-redis/` — Redis Streams implementation
   - `crates/state-store/` — KV state store trait
   - `crates/state-store-redis/` — Redis KV implementation
   - `crates/sweeper/` — sweeper + archiver
2. Implement transport trait and envelope first — this is the contract everything else depends on
3. Implement Redis Streams backend — validates the abstraction against real infrastructure
4. Domain schemas come later as each consuming project onboards
